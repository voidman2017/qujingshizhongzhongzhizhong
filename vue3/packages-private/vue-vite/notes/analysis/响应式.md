# packages/reactivity/src/reactive.ts

## createReactiveObject

### 核心实现

1. 初始化
   1. 类型检查：只有对象类型才能被代理
   2. 避免重复代理：如果目标已经是代理对象，直接返回
   3. 缓存检查：如果已经存在对应的代理，直接返回缓存的代理
2. 创建 Proxy：根据目标类型选择不同的处理器
3. 缓存代理对象并返回

### 设计亮点

1. 性能优化

- 使用 WeakMap 缓存代理对象，避免重复创建
- 类型检查在代理创建前进行，减少不必要的 Proxy 创建
- 通过 ReactiveFlags 快速识别对象状态

2. 类型安全

- 完整的 TypeScript 类型定义
- DeepReadonly 类型确保只读对象的类型安全
- UnwrapNestedRefs 处理嵌套 ref 的自动解包

3. 灵活的处理器系统

- 普通对象使用 baseHandlers
- 集合类型使用 collectionHandlers
- 支持深度和浅层两种模式
- 支持可变和只读两种状态

4. 边界情况处理

- 防止对已代理对象的重复代理
- 处理只读对象上调用 reactive() 的情况
- 对不可扩展对象的特殊处理

### 相关问题

#### handler选择逻辑

1.Collection Handler (collectionHandlers)

使用场景： 当 targetType === TargetType.COLLECTION 时

适用对象类型：

- Map
- Set
- WeakMap
- WeakSet

特点：

- 专门处理集合类型的响应式转换
- 需要拦截集合特有的方法（如 get , set , add , delete , clear , forEach 等）
- 处理迭代器方法（ keys() , values() , entries() , Symbol.iterator ）
- 维护集合内部元素的响应式状态

2.Base Handler (baseHandlers)

使用场景： 当 targetType === TargetType.COMMON 时

适用对象类型：

- 普通对象 ( Object )
- 数组 ( Array )

特点：

- 处理对象属性的 get 、 set 、 has 、 deleteProperty 等操作
- 对数组进行特殊处理，拦截会改变数组长度的方法
- 处理属性访问和修改的依赖收集与触发更新

eg：

使用 `const obj = reactive({})` 创建响应式对象时，	会选择 baseHandlers 作为 Handler。baseHandlers 即 createReactiveObject 方法的第三个参数，该 handler 来源： mutableHandlers (packages/reactivity/src/baseHandlers.ts)-> `class MutableReactiveHandler extends BaseReactiveHandler` ,继承自 BaseReactiveHandler

#### collectionHandlers 只需要getter而不需要setter

在 Vue3 的响应式系统中，packages/reactivity/src/collectionHandlers.ts 

```
export const mutableCollectionHandlers: ProxyHandler<CollectionTypes> = {
  get: /*@__PURE__*/ createInstrumentationGetter(false, false),
}
```

只定义了 `get` 拦截器而没有 `set` 拦截器，这是有深层设计原因的：

1. 集合类型的特殊性

集合类型（Map、Set、WeakMap、WeakSet）与普通对象不同：

**普通对象**：通过 `obj.prop = value` 或 `obj[key] = value` 进行赋值

**集合类型**：通过方法进行操作，如 `map.set(key, value)`、`set.add(value)` 等

2. 方法拦截 vs 属性拦截

集合类型的修改操作都是通过方法完成的，而不是直接的属性赋值：

```javascript
// 集合类型的操作方式
map.set('key', 'value')  // 通过 set 方法
set.add('item')          // 通过 add 方法
map.delete('key')        // 通过 delete 方法
set.clear()              // 通过 clear 方法

// 而不是直接赋值
// map['key'] = 'value'  // 这样做是无效的
```

3. getter 中的方法增强

在 `createInstrumentationGetter` 中，当访问集合的方法时（如 `set`、`add`、`delete` 等），会返回经过增强的方法：

```typescript
return Reflect.get(
  hasOwn(instrumentations, key) && key in target
    ? instrumentations  // 返回增强后的方法
    : target,
  key,
  receiver,
)
```

这些增强后的方法在 `createInstrumentations` 函数中定义，包含了：

- **依赖追踪**：`track()` 调用
- **变更触发**：`trigger()` 调用
- **响应式转换**：对值进行 `toReactive()` 等处理

4. 为什么不需要 setter
5. **没有直接属性赋值**：集合类型不支持 `collection[key] = value` 这种赋值方式
6. **方法已经被拦截**：所有的修改操作都通过方法进行，而这些方法在 getter 中已经被替换为增强版本
7. **完整的响应式支持**：通过方法拦截已经实现了完整的响应式功能，包括依赖收集和变更通知
8. 对比普通对象的处理

普通对象需要 setter 是因为：

```javascript
// 普通对象的赋值会触发 setter
obj.prop = 'new value'  // 需要 setter 拦截
obj['key'] = 'value'    // 需要 setter 拦截
```

而集合类型的所有操作都是方法调用，通过 getter 拦截方法访问就足够了。

总结

集合类型的响应式实现采用了**方法拦截**而非**属性拦截**的策略，这是因为集合类型的 API 设计本身就是基于方法的。通过在 getter 中返回增强后的方法，Vue3 巧妙地实现了对集合类型的完整响应式支持，而无需额外的 setter 拦截器。

# packages/reactivity/src/effect.ts

## effect

## ReactiveEffect
